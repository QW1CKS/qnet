# T6.7 — Stealth Browser Application: Playbook & Acceptance

Status: In progress (M1 complete; M2 repo-local acceptance done: external seeds + DPI parity; QUIC parity evidence added)
Owner: TBD • Reviewers: Core, Security, Perf
Timebox: ~8 weeks (see milestones)
Dependencies: T6.1–T6.6 complete (toolkit, HTX, perf, compliance)

---

## recent updates (2025-09-11)
- M1 complete: local SOCKS5 → HTX loop validated; structured logging; headless on Windows.
- M2 shaping landed behind feature flag (code-complete in repo):
  - Variable record sizing in `htx` mux; deterministic profiles in `core-framing::sizing`.
  - Bounded timing jitter threaded into mux (backpressure-aware); deterministic seeds via env.
  - STREAM padding applied pre-AEAD (payload = id||len||data||pad); decoder remains backward-compatible.
  - Plaintext zeroization after encode when stealth-mode enabled.
  - ALPN/JA3 template rotation via env allow-list in `htx::tls_mirror` with 24h cache; TemplateID via deterministic CBOR.
  - Tests: sizing/jitter determinism, padded decode (plain/encrypted) and AEAD round-trip with padding, JA3 variance across rotated templates.
- Pending in M2: external bootstrap seeds acceptance run (<30s) and QUIC mode parity; DPI helper scripts are present; CI wiring planned for M5.

- M2 decoy routing (new):
  - Added signed decoy catalog loader and resolver in `htx::decoy`:
    - Schema: `DecoyCatalog` (version, updated_at, entries) + `SignedCatalog { catalog, signature_hex }`.
    - Signature: Ed25519 over deterministic CBOR of `catalog`; hex-encoded signature.
    - Env knobs: `STEALTH_DECOY_PUBKEY_HEX`, `STEALTH_DECOY_CATALOG_JSON`, optional `STEALTH_DECOY_ALLOW_UNSIGNED=1` for dev.
    - Resolver: host-pattern match with weighted rotation; optional ALPN override per entry.
  - Integration: `htx::api::dial()` consults the decoy resolver; routes to decoy host/port and applies ALPN override into template selection.
  - Tests: signature verification and resolver selection/ALPN override.

- M2 plausibility logging (new):
  - Added optional redacted logs in `htx::api::dial()` when env `STEALTH_LOG_DECOY_ONLY=1` is set. When enabled, logs surface only decoy host/port when routing via decoys; real destinations are suppressed.

- M2 bootstrap (new skeleton):
  - Added `htx::bootstrap` with signed seed catalog (`SeedCatalog`, `SignedSeeds`) and verifier (Ed25519 over DET-CBOR), env loader (`STEALTH_BOOTSTRAP_CATALOG_JSON`, `STEALTH_BOOTSTRAP_PUBKEY_HEX`, optional `STEALTH_BOOTSTRAP_ALLOW_UNSIGNED`).
  - Backoff iterator with jitter (0.5s → 8s cap, ±10% jitter), deterministic test mode; simple 24h cache type for successful seeds.
  - Tests: signed catalog verification, backoff cumulative time stays under 30s for multiple failures, cache get/put, weighted pick behavior.

- M2 bootstrap integration (update):
  - Added `htx::bootstrap::try_connect_loop` with injectable probe and sleep, using deterministic backoff to retry seeds until success or timeout. Unit test demonstrates success path in <29s with failures then success.
  - `htx::api::dial()` gates dials behind a seed health check via `connect_seed_from_env(timeout=29s)` when bootstrap env is present.

- Local bootstrap acceptance (dev harness):
  - Added `qnet-spec/templates/bootstrap-acceptance.sh` which spins up a local HTTP `/health` server and runs `crates/htx/examples/bootstrap_check.rs` against it using unsigned seeds via env. This validates the bootstrap gate path end-to-end without requiring trusted TLS.
  - Expected output: `bootstrap: ok -> http://127.0.0.1:<port>` within the configured timeout (default 10s in the script).

- DPI harness (new):
  - Added templates: `qnet-spec/templates/dpi-capture.sh` and `qnet-spec/templates/dpi-compare.py` for local CDF checks vs a Chrome baseline. CI wiring will land in M5.

- Linux validation and parity (2025-09-11):
  - Local bootstrap acceptance harness validated on Ubuntu: observed `bootstrap: ok -> http://127.0.0.1:<port>` under 10s.
  - QUIC parity benches (`core-mesh` echo with `--features "with-libp2p quic"`) show no regressions vs TCP in the current suite; scheduler tuning remains for M3.
  - Evidence: QUIC parity — core-mesh echo (quick mode) p50 and p95 within ±0.2% of TCP across 4 scenarios; see `artifacts/perf-summary.md` for table and raw medians.
  - PREFER_QUIC wiring landed in `htx::mux`: when `PREFER_QUIC` is truthy and `HTX_SCHEDULER_PROFILE` is unset, defaults to HTTP-friendly window/chunk sizes (unit test added).
  - Headless Linux build: `apps/stealth-browser/build.rs` gates `tauri_build` behind the `with-tauri` feature to keep CI/headless builds green without GUI deps.

## repo-local parity evidence (2025-09-12)
- Added a simple RR write scheduler in `htx::mux` (enabled by `HTX_SCHEDULER_RR=1` or when `HTX_SCHEDULER_PROFILE=http` / `PREFER_QUIC=1`).
- Deterministic unit test verifies small stream completes under large-stream contention.
- Micro-benchmark added: `crates/htx/benches/mixed_concurrency.rs` (feature `perf-bench`).
  - Run: `cargo bench -p htx --features perf-bench --bench mixed_concurrency`
  - Notes: sets `HTX_SCHEDULER_RR=1` and `HTX_SCHEDULER_PROFILE=http` during the bench; captures small-stream completion behavior under contention.
  - Use alongside `core-mesh` benches (TCP vs QUIC) to compare p50/p95; see `crates/core-mesh/benches/echo.rs` (enable `--features "with-libp2p quic"`).

## objective
Build a user-facing stealth browser that:
- Mimics standard HTTPS (TCP-443/QUIC-443) so traffic is indistinguishable in packet captures.
- Auto-connects globally within 30 seconds using public bootstrap seeds.
- Routes via configurable decoy IPs/domains to keep ISP logs plausible.
- Lets users browse censored sites with <200ms added latency over baseline.

Success criteria:
- DPI evasion: On Wireshark, traffic looks like normal HTTPS; no QNet signatures.
- Connectivity: First successful connection <30s on commodity networks.
- UX: Can reach a known blocked domain via QNet path; page content loads; no visible warnings.
- Ops: Installers for Windows/macOS/Linux with auto-daemon launch.

---

## deliverables
- apps/stealth-browser/ (Tauri-based desktop app)
  - src-tauri/: Rust backend; integrates QNet client and control plane
  - ui/: Minimal UI (address bar, status, settings)
  - config/: Decoy list, bootstrap seeds, feature flags
- crates/htx + crates/core-framing
  - "stealth-mode" feature flag: TLS-like record sizing, padding, ALPN shaping, JA3-aligned templates
  - Decoy routing: config-driven list of domains/IPs for plausible egress
  - Bootstrap seeds: public nodes list and fallback mechanics
- Installers
  - Windows MSI (WiX or NSIS), macOS DMG, Linux AppImage
- CI
  - Build-and-sign (dev certs) of installers on tagged releases
  - DPI check job with pcap artifact (synthetic capture)
- Docs
  - apps/README.md with quick start
  - qnet-spec/specs/001-qnet/T6.7-playbook.md (this file)
  - Acceptance and test scripts (Wireshark/DPI guidance)

---

## architecture
- App shell: Tauri (Rust backend + WebView UI)
- Network path: Browser -> local SOCKS5 inside Tauri -> HTX tunnel -> QNet peers
- Stealth layer (crates/core-framing + crates/htx):
  - Origin-mirrored TLS templates (reusing T2.x capabilities)
  - TLS-like record splitting, padding, timing jitter (bounded)
  - QUIC/TCP toggles; auto-calibration per path
- Config
  - Decoy catalog (well-known domains, rotating)
  - Bootstrap seeds + backoff plan
  - Feature flags: stealth-mode, prefer-quic, measure-latency

---

## gap analysis — what’s missing to hit T6.7

These items are not yet present in the codebase and must be implemented to satisfy the objectives and success criteria. Each bullet maps to milestones below.

- App shell and local proxy (M1)
  - Tauri app skeleton in `apps/stealth-browser/` with Rust backend
  - Embedded SOCKS5 proxy bound to 127.0.0.1 and exposed in the UI
  - Minimal UI (address bar, status, basic settings) and request path via SOCKS→HTX

- Stealth-mode implementation (M2)
  - TLS-like record splitting/sizing and bounded padding strategies with tests
  - Timing jitter for inter-record gaps with deterministic test mode
  - ALPN shaping and JA3-aligned ClientHello templates with rotation policy
  - QUIC/TCP auto-calibration and HTTP-like stream scheduling defaults

- Decoy routing and plausibility (M2–M3)
  - Decoy catalog schema (JSON/CBOR) with signed presets
  - Resolver mapping real destinations to decoys; rotation policies (time/volume)
  - Log-plausibility alignment: SNI/ALPN/template consistency with chosen decoy

- Global bootstrap and resilience (M2)
  - Public bootstrap seed list (deployed infra), health checks
  - Fallback/backoff/caching to achieve <30s first connection on commodity networks

- Validation harnesses (M5)
  - DPI parity harness: pcap generation and comparison vs Chrome baseline; CI artifact
  - E2E page-load/TTFB latency measurements with <200ms added median target
  - Censorship-route tests and simulated ISP-log verification (decoys only visible)

- Packaging and CI (M4)
  - Build scripts for Windows MSI, macOS DMG, Linux AppImage
  - CI matrix (linux/windows/macos), dev-signing, artifact publication
  - Auto-daemon launch and firewall prompt guidance for installers

- Security and hardening (M6)
  - Zeroize secrets; buffer limits; WebView sandboxing and CSP
  - Config preset signing and verification; safe local overrides
  - SBOM + dependency audit; threat model doc and checklist

Note: Meeting the <30s global-connect target depends on operating real, reachable bootstrap seed nodes. This external infrastructure must be provisioned alongside code changes.

---

## milestone plan (phased)

### M1 — Foundation (Week 1–2) [M1: Done]
- [x] Scaffold Tauri app in apps/stealth-browser/
- [x] Embed minimal Rust backend (tokio runtime, config loader)
- [x] Integrate local SOCKS5 proxy bound on 127.0.0.1:PORT
- [x] Wire HTX dial/accept via existing crates; basic echo to validate path
- [x] Logging: structured logs, rotating files, redact secrets
  (UI items moved to M3)

Exit (Done): Can load a simple HTTP(S) site via HTX tunnel using SOCKS proxy (validated via curl over SOCKS).

### M2 — Stealth networking (Week 3–4) [M2: Done]
- [x] Implement feature flag: htx/stealth-mode
  - Crates: `htx`, `core-framing`
  - Cargo features: `stealth-mode` (default: off)
  - Runtime env toggles (dev/test): `STEALTH_SIZING_PROFILE=small|webby|bursty`, `STEALTH_JITTER_PROFILE=small|webby`, `STEALTH_SIZER_SEED`, `STEALTH_JITTER_SEED`
  - Behavior: when on, enable variable record sizing and bounded jitter in HTX mux write path; STREAM padding applied pre-AEAD; ALPN/JA3 shaping via template rotation.
- [x] TLS-like record sizing and padding profiles (small, webby, bursty)
  - [x] Profiles implemented in `core-framing::sizing` with deterministic seeds; bounded ≤64KiB
  - [x] Integrated into HTX mux to shape send chunk size prior to encryption
  - [x] Padding: right-pad applied in HTX STREAM frames (id||len||data||pad) before AEAD; decode remains backward-compatible
  - [x] Zeroize temporary/plaintext buffers after encode when stealth-mode enabled
  - [x] Tests: AEAD round-trip with padding; padded decode (plain/encrypted)
  - [x] Tests: distribution sanity (CDF buckets) for sizing profiles (Webby majority ≤10KiB)
- [x] Timing jitter (bounded) for inter-record gaps
  - [x] Jitter implemented and threaded into HTX mux (sleep before send); deterministic seeds via env
  - [x] Back-pressure aware: skip jitter if we just blocked on credit
  - [x] Tests: determinism with fixed seed
  - [x] Tests: bound checks for Webby profile (2–15ms)
- [x] ALPN shaping and JA3-aligned client hello templates
  - Source: reuse `utls-gen` output and `htx::tls_mirror` calibrations; cache for 24h
  - Rotation: per-conn template rotation via env allow-list (M2 PoC); signed catalog + cadence policy next
  - ALPN order preserved from template; enforce extension order
  - Tests: TemplateID stability and JA3 variance across rotations
  - [x] Tests: JA3 parity vs reference fixtures; rotation cadence tests
- [x] QUIC mode parity: stream scheduling + flow-control defaults for web traffic
  - [x] Add `prefer_quic` config (wired: `PREFER_QUIC` biases scheduler to HTTP-friendly defaults when no explicit profile is set)
  - Align stream concurrency to HTTP/2-like patterns (future when QUIC datapath enabled)
  - [x] Scheduler: weight smaller streams, fair-queue/coalesce small writes; window defaults tuned for TTFB (RR scheduler in `htx::mux`)
  - [x] Tests/benches: deterministic mixed small/large unit test in HTX and a mixed concurrency bench; p50/p95 comparison available via `core-mesh` TCP vs QUIC echo benches
- [x] Configurable decoy routing (domains/IPs) with rotation policies
  - [x] Schema: signed JSON/CBOR { version, updated_at, entries: [ {host_pattern, decoy_host, alpn?, port?, weight?} ], signature_hex }
  - [x] Signature: Ed25519 over deterministic CBOR; env-pinned pubkey via `STEALTH_DECOY_PUBKEY_HEX`
  - [x] Resolver: map real destination → decoy with weighted rotation; optional ALPN override
  - [x] Logs: surface only decoy host/IP when enabled (plausibility)
  - [x] Tests: signature verify; resolver selection and ALPN override
- [x] Bootstrap seed list + fallback + backoff + caching
  - [x] Seeds: signed list schema + verifier (same mechanism as decoys); env loader
  - [x] Backoff: 0.5s → 8s exponential with jitter; cap 30s; 24h cache type
  - [x] Tests: signature verify; backoff under <30s cumulative in failure loop; cache; weighted pick; try_connect_loop succeeds under 29s in unit test
  - [x] Integration hook: env-driven bootstrap gate before dial; health probe (`/health`) with rustls client
  - [x] External seeds + acceptance run: demonstrate <30s first connect using deployed seeds
    - Evidence (2025-09-12): artifacts/bootstrap/run_1.txt, run_2.txt, run_3.txt (all <1.2s); seeds recorded in artifacts/bootstrap/seeds_used.json; method: Cloudflare Quick Tunnel (public HTTPS) on two laptops

Exit (Done): Packet capture is visually indistinguishable from HTTPS for standard browsing flows.
  - Evidence (2025-09-12): artifacts/dpi/qnet-stealth-20250912_142733.pcapng vs artifacts/dpi/chrome-baseline-20250912_142541.pcapng
    - Comparator output: Result: PASS (max Δ=0.028, threshold=0.100); Packets: stealth=16377 baseline=6363
    - Method: Windows Wireshark/tshark capture for 60s each using `qnet-spec/templates/dpi-capture.ps1` (Interface: Wi‑Fi index 3), compared via `qnet-spec/templates/dpi-compare.py`

M2 implementation notes
- Feature flag plumbing
  - Thread the `stealth-mode` feature through `htx` and `core-framing`; expose a runtime config toggle to allow on/off without rebuild (test-only acceptable to require rebuild for M2).
- Record sizing & padding
  - Implemented variable chunk sizing in mux write path under feature flag; respects remote credit (never exceeds WINDOW_UPDATE).
  - Implemented right-padding at STREAM frame level (payload = id||len||data||pad) so record on wire matches target length. Decoder supports legacy frames (id||data) seamlessly.
  - Zeroization of plaintext buffers after encode is enabled under stealth-mode. Add distribution tests next.
- Timing jitter
  - Implemented: apply delay right before send when credit is available; skipped if we blocked on credit wait.
  - Add metrics hooks (disabled by default) to measure added delay distributions.
- ALPN/JA3 shaping
  - Implemented env-driven allow-list rotation and 24h cache; TemplateID computed via deterministic CBOR; JA3 hash varies across templates. Validate with Wireshark JA3 plugin and captured pcaps from Chrome/Firefox baselines.
  - Keep a minimal signed template catalog; prefer dynamic calibration where allowed.
- Decoy routing
  - Implemented `htx::decoy` module with signed catalog loader (DET-CBOR + Ed25519) and resolver with weighted rotation and optional ALPN override. Enabled via env: `STEALTH_DECOY_CATALOG_JSON`, `STEALTH_DECOY_PUBKEY_HEX`, optional `STEALTH_DECOY_ALLOW_UNSIGNED` for dev.
  - `htx::api::dial()` consumes resolver output to route to decoy host/port and pass ALPN override to template selection. Start with DNS-over-OS; future: DoH/DoT if required.
  - Keep resolver optional; when off, behavior defaults to calibration/allow-list paths. Optional redaction via `STEALTH_LOG_DECOY_ONLY=1` hides real destinations in logs.

Env controls (M2)
- STEALTH_SIZING_PROFILE, STEALTH_SIZER_SEED
- STEALTH_JITTER_PROFILE, STEALTH_JITTER_SEED
- STEALTH_TPL_ALLOWLIST (ALPN/JA3 template rotation)
- STEALTH_DECOY_CATALOG_JSON, STEALTH_DECOY_PUBKEY_HEX, STEALTH_DECOY_ALLOW_UNSIGNED
- STEALTH_LOG_DECOY_ONLY (when =1, redact real destination in logs if decoys are used)
- Bootstrap
  - Provide a local fallback (loopback HTX) in dev; real seeds gated by infra availability.
  - `PREFER_QUIC=0|1`: when truthy and `HTX_SCHEDULER_PROFILE` is unset, defaults scheduler to the HTTP profile (initial_window=256KiB, base_chunk=16KiB).
  
HTX scheduler controls (M2)
- HTX_SCHEDULER_PROFILE: "http" enables initial_window=256KiB and base_chunk=16KiB (HTTP-friendly). Default profile uses 64KiB/4KiB.
- HTX_INITIAL_WINDOW: override initial receive window (bytes).
- HTX_CHUNK: override base chunk size (bytes, 512..64KiB).

Config examples (M2)
- Decoys: copy `qnet-spec/templates/decoy-catalog.example.json` and set `STEALTH_DECOY_CATALOG_JSON` to its contents (or path if your launcher reads files). For signed use, also set `STEALTH_DECOY_PUBKEY_HEX` and wrap as `{ "catalog": {…}, "signature_hex": "…" }`.
- Bootstrap: copy `qnet-spec/templates/bootstrap-seeds.example.json` and set `STEALTH_BOOTSTRAP_CATALOG_JSON`; for signed use, also set `STEALTH_BOOTSTRAP_PUBKEY_HEX`.

M2 validation
- Unit tests
  - Sizing distributions and bounds
  - Padding correctness and AEAD integrity
  - Jitter determinism and bounds
  - Template ID/JA3 parity vs fixtures
  - Decoy/seed signature verification
- Integration tests
  - E2E: SOCKS → HTX with `stealth-mode` enabled; confirm payload delivery and bounded added delay
  - DPI: capture 60s browsing of three sites; compare record size CDFs within ±10% to Chrome baseline
  - Connectivity: <30s first connect using a seeded simulation or local proxy of seed endpoints
- CI artifacts
  - Store pcaps and summary in `artifacts/dpi/` with host/date/version metadata
  - Attach distribution plots for record sizes and inter-record gaps
  - Scripts available: `templates/dpi-capture.sh` and `templates/dpi-compare.py`

How to run (local, optional)
- Capture stealth run: enable `stealth-mode`, exercise browsing via the SOCKS proxy, then run: `templates/dpi-capture.sh qnet-stealth`
- Capture baseline (Chrome): browse the same sites, then run: `templates/dpi-capture.sh chrome-baseline`
- Compare: `python3 templates/dpi-compare.py artifacts/dpi/qnet-stealth-*.pcap artifacts/dpi/chrome-baseline-*.pcap`

### M3 — UX + resilience (Week 5)
- [ ] UI: address bar + Go; open via embedded request client through SOCKS
  - [ ] Design and implement address bar UI (HTML/CSS/JS in Tauri frontend)
  - [ ] Wire "Go" button to send URL to Rust backend via Tauri's IPC
  - [ ] Integrate embedded request client to handle navigation through SOCKS proxy
  - [ ] Add basic navigation controls (back/forward, refresh)
- [ ] Basic settings panel (port, bootstrap toggle)
  - [ ] Create settings UI panel (modal or sidebar) with form inputs
  - [ ] Add SOCKS port configuration (default 1080, editable)
  - [ ] Implement bootstrap toggle (enable/disable seed discovery)
  - [ ] Wire settings to persist in local config (e.g., JSON file)
- [ ] Settings for decoy list management (preset + custom)
  - [ ] Display preset decoy catalogs (e.g., Cloudflare, custom list)
  - [ ] Allow adding/removing custom decoys (host, port, ALPN)
  - [ ] Validate decoy entries (e.g., reachable, valid format)
  - [ ] Save decoy config to STEALTH_DECOY_CATALOG_JSON env or file
- [ ] Connectivity health: spinner, retry UI, error surfaces
  - [ ] Add status indicator (connected/calibrating/offline) with spinner animation
  - [ ] Implement retry button for failed connections
  - [ ] Surface error messages (e.g., "Bootstrap failed: no healthy seeds")
  - [ ] Poll connectivity status from Rust backend every 5s
- [ ] First-run wizard: consent + quick calibration (origin selection)
  - [ ] Create multi-step wizard UI (consent page, origin selection)
  - [ ] Add privacy consent checkbox and terms link
  - [ ] Implement origin calibration (test connection to selected site)
  - [ ] Skip wizard on subsequent runs (flag in config)
- [ ] Auto-update channel (optional, dev certs) or release notes fetcher
  - [ ] Fetch latest release notes from GitHub API on app start
  - [ ] Display update notifications (optional, non-intrusive)
  - [ ] Implement basic auto-update for dev builds (Tauri supports this)
- [ ] Crash reporting (local-only logs, no telemetry exfiltration)
  - [ ] Capture and log errors to local file (e.g., app_data/logs/)
  - [ ] Add "Export Logs" button in settings for user download
  - [ ] Ensure no data is sent externally (local-only)

Exit: Usable for non-technical users with clear state and recovery.

### M4 — Packaging (Week 6)
- [ ] Windows MSI build (WiX/NSIS) with start menu entry
- [ ] macOS universal build + DMG with app bundle IDs
- [ ] Linux AppImage with desktop file
- [ ] Post-install first-run check and firewall prompts guidance

Exit: Installers build reproducibly on CI and run on clean VMs.

### M5 — DPI & censorship tests (Week 7)
- [ ] Wireshark test playbook with golden pcaps (local lab)
- [ ] ISP-log simulation (squid/sflow) shows decoy sites only
- [ ] Known-blocked domains reachable via QNet
- [ ] Added latency measured (<200ms over direct baseline on clean path)

Exit: Acceptance criteria validated with artifacts.

### M6 — Security & hardening (Week 8)
- [ ] Memory limits for buffers; zeroize secrets
- [ ] Sandboxing constraints for WebView
- [ ] Integrity of config (signed presets) and safe overrides
- [ ] Dependency audit; lockfile maintained
- [ ] Threat model doc + mitigations checklist

Exit: Security review completed, issues triaged or fixed.

---

## detailed checklists

### app scaffolding
- [x] Create apps/stealth-browser via `tauri init`
- [x] Add `qnet` workspace integration (Cargo workspace member)
- [x] Backend: tokio, tracing, serde, config hot-reload
- [ ] SOCKS5 proxy: expose bound address to UI
- [x] Basic request through SOCKS -> HTX (in-proc) -> HTTP 200 echo

### stealth-mode (htx/core-framing)
- [x] Feature flag `stealth-mode` plumbed end-to-end
- [x] Record sizing strategy module + tests (deterministic profiles)
- [x] Padding correctness tests (AEAD round-trip, back-compat decode); [x] bounds/distribution CDF tests
- [x] Timing jitter with deterministic test mode
- [x] ALPN/JA3 selection + env allow-list rotation; [x] parity fixtures + cadence policy
- [x] QUIC stream scheduler tuned for HTTP-like concurrency

### decoy routing & bootstrap
- [x] Decoy catalog schema (JSON/CBOR) + signed preset (Ed25519 over DET-CBOR)
- [x] Resolver that maps destinations to decoys (host-pattern) with ALPN override
- [x] Rotation policy (weighted round-robin; time/volume cadence can extend later)
- [x] Bootstrap seeds list + health checks (`/health`), env loader
- [x] Backoff + cache (0.5s→8s, ±10% jitter); [ ] offline mode messaging (UI)

### UX & controls
- [ ] Address bar + navigation
- [ ] Status indicators: Connected / Calibrating / Offline
- [ ] Settings: decoys, transports (TCP/QUIC/auto), data saver
- [ ] First-run wizard + consent
- [ ] Local-only crash logs export button

### packaging & distribution
- [ ] Windows: code signing (dev), MSI installer
- [ ] macOS: app bundle + DMG, notarization (dev)
- [ ] Linux: AppImage + desktop entry
- [ ] CI: build matrix per OS, artifacts uploaded

### testing & validation
- [ ] Unit tests for padding, record sizing, jitter
- [ ] Integration: SOCKS -> HTX tunnel E2E page load
- [ ] DPI: pcap diff vs. baseline Chrome to ensure parity
- [ ] Latency: added latency <200ms on reference links
- [ ] Censorship: reach blocked domain via QNet

### security
- [ ] Zeroize on key material
- [ ] Minimize capability of WebView; CSP for UI
- [ ] Config signatures verified; local overrides whitelisted
- [ ] SBOM + dependency audit

---

## acceptance checklist
- [x] Traffic looks like HTTPS in Wireshark (indistinguishable at record/packet level)
  - Evidence (2025-09-12): PASS (max Δ=0.028) comparing `artifacts/dpi/qnet-stealth-20250912_142733.pcapng` vs `artifacts/dpi/chrome-baseline-20250912_142541.pcapng`
- [x] First connection completes in <30s using public bootstrap
- [ ] Decoy IPs/domains logged (plausible destinations); real targets masked
- [ ] Browsing a blocked site works end-to-end
- [ ] Added latency <200ms (median) compared to direct
- [ ] Installers produced for Win/macOS/Linux and run on clean VMs
- [ ] CI green: build, basic E2E test, DPI pcap artifact
- [ ] Security review items addressed or accepted

---

## test playbooks

### wireshark / DPI parity
1) Start the browser with `stealth-mode` enabled.
2) Capture loopback (Linux: `any`) for 60s while loading 3 common sites.
3) Save pcap. Compare against Chrome baseline:
   - TLS record sizes distribution (CDF) within ±10%
   - Inter-record timing jitter bounded and similar
   - ALPN and handshake extensions consistent with template
4) Archive pcap under `artifacts/dpi/` with run metadata (host, date, version).

See `qnet-spec/templates/DPI-README.md` for a full Windows/Linux guide.

Windows quickstart (admin PowerShell)
- Ensure Npcap is running: `Set-Service npcap -StartupType Automatic; Start-Service npcap`
- List interfaces: `tshark -D` (or run by full path)
- Capture baseline: `./qnet-spec/templates/dpi-capture.ps1 -Label chrome-baseline -DurationSeconds 60 -Interface <idx or name>`
- Capture stealth: `./qnet-spec/templates/dpi-capture.ps1 -Label qnet-stealth -DurationSeconds 60 -Interface <same>`
- Compare: `py ./qnet-spec/templates/dpi-compare.py artifacts/dpi/qnet-stealth-*.pcapng artifacts/dpi/chrome-baseline-*.pcapng`

### connectivity / bootstrap
- Cold start on a fresh VM, block direct DNS to target site, allow standard HTTPS.
- Expect connection established <30s; status becomes Connected.

### censorship route
- Configure a known blocked hostname; verify page load via QNet tunnel.
- ISP log simulation (squid/sflow) shows only decoy destinations.

### latency budget
- Measure direct vs. via-QNet TTFB on fixed asset set.
- Added median latency <200ms.

---

## ci considerations
- Matrix builds for linux/windows/macos
- Cache cargo + tauri deps
- Jobs:
  - Build installers (dev-signed), upload artifacts
  - Run headless E2E smoke (load a static page via embedded HTTP server over HTX)
  - Run synthetic DPI test and publish pcap
  - SBOM + audit

---

## risks & mitigations
- Advanced DPI evolves fast → Maintain multiple templates; quick-update channel
- Decoy catalog abuse → Signed presets; community-reviewed lists
- Legal exposure in restrictive regimes → Prominent disclaimers; jurisdiction-aware defaults
- Performance regressions → Perf guardrails; opt-out of heavy jitter on slow links

---

## artifacts to produce
- apps/stealth-browser installers (MSI, DMG, AppImage)
- pcap comparisons in artifacts/dpi/
- Latency report and acceptance notes in artifacts/browser/
- Decoy catalog snapshot with signature

---

## references
- Spec tasks: qnet-spec/specs/001-qnet/tasks.md (T6.7)
- Prior work: T2.x TLS mirroring, T6.6 perf infra
- Tech choices: Tauri, tokio, quinn/rustls, serde
