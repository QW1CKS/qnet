# T6.7 — Stealth Browser Application: Playbook & Acceptance

Status: In progress (M1 complete; M2 repo-local acceptance done: external seeds + DPI parity; QUIC parity evidence added; M3 complete: catalog-first path working end-to-end with bundled+signed+updater+fallback surfaced in status API; edge gateway enables production masked browsing; Windows validation successful)
Owner: TBD • Reviewers: Core, Security, Perf
Timebox: ~8 weeks (see milestones)
Dependencies: T6.1–T6.6 complete (toolkit, HTX, perf, compliance)

---

## recent updates (2025-09-11)
- M1 complete: local SOCKS5 → HTX loop validated; structured logging; headless on Windows.
- M2 shaping landed behind feature flag (code-complete in repo):
  - Variable record sizing in `htx` mux; deterministic profiles in `core-framing::sizing`.
  - Bounded timing jitter threaded into mux (backpressure-aware); deterministic seeds via env.
  - STREAM padding applied pre-AEAD (payload = id||len||data||pad); decoder remains backward-compatible.
  - Plaintext zeroization after encode when stealth-mode enabled.
  - ALPN/JA3 template rotation via env allow-list in `htx::tls_mirror` with 24h cache; TemplateID via deterministic CBOR.
  - Tests: sizing/jitter determinism, padded decode (plain/encrypted) and AEAD round-trip with padding, JA3 variance across rotated templates.
- Pending in M2: external bootstrap seeds acceptance run (<30s) and QUIC mode parity; DPI helper scripts are present; CI wiring planned for M5.

- M2 decoy routing (new):
  - Added signed decoy catalog loader and resolver in `htx::decoy`:
    - Schema: `DecoyCatalog` (version, updated_at, entries) + `SignedCatalog { catalog, signature_hex }`.
    - Signature: Ed25519 over deterministic CBOR of `catalog`; hex-encoded signature.
    - Env knobs: `STEALTH_DECOY_PUBKEY_HEX`, `STEALTH_DECOY_CATALOG_JSON`, optional `STEALTH_DECOY_ALLOW_UNSIGNED=1` for dev.
    - Resolver: host-pattern match with weighted rotation; optional ALPN override per entry.
  - Integration: `htx::api::dial()` consults the decoy resolver; routes to decoy host/port and applies ALPN override into template selection.
  - Tests: signature verification and resolver selection/ALPN override.

- M2 plausibility logging (new):
  - Added optional redacted logs in `htx::api::dial()` when env `STEALTH_LOG_DECOY_ONLY=1` is set. When enabled, logs surface only decoy host/port when routing via decoys; real destinations are suppressed.

- M2 bootstrap (new skeleton):
  - Added `htx::bootstrap` with signed seed catalog (`SeedCatalog`, `SignedSeeds`) and verifier (Ed25519 over DET-CBOR), env loader (`STEALTH_BOOTSTRAP_CATALOG_JSON`, `STEALTH_BOOTSTRAP_PUBKEY_HEX`, optional `STEALTH_BOOTSTRAP_ALLOW_UNSIGNED`).
  - Backoff iterator with jitter (0.5s → 8s cap, ±10% jitter), deterministic test mode; simple 24h cache type for successful seeds.
  - Tests: signed catalog verification, backoff cumulative time stays under 30s for multiple failures, cache get/put, weighted pick behavior.

- M2 bootstrap integration (update):
  - Added `htx::bootstrap::try_connect_loop` with injectable probe and sleep, using deterministic backoff to retry seeds until success or timeout. Unit test demonstrates success path in <29s with failures then success.
  - `htx::api::dial()` gates dials behind a seed health check via `connect_seed_from_env(timeout=29s)` when bootstrap env is present.

- Local bootstrap acceptance (dev harness):
  - Added `qnet-spec/templates/bootstrap-acceptance.sh` which spins up a local HTTP `/health` server and runs `crates/htx/examples/bootstrap_check.rs` against it using unsigned seeds via env. This validates the bootstrap gate path end-to-end without requiring trusted TLS.
  - Expected output: `bootstrap: ok -> http://127.0.0.1:<port>` within the configured timeout (default 10s in the script).

- DPI harness (new):
  - Added templates: `qnet-spec/templates/dpi-capture.sh` and `qnet-spec/templates/dpi-compare.py` for local CDF checks vs a Chrome baseline. CI wiring will land in M5.

- Linux validation and parity (2025-09-11):
  - Local bootstrap acceptance harness validated on Ubuntu: observed `bootstrap: ok -> http://127.0.0.1:<port>` under 10s.
  - QUIC parity benches (`core-mesh` echo with `--features "with-libp2p quic"`) show no regressions vs TCP in the current suite; scheduler tuning remains for M3.
  - Evidence: QUIC parity — core-mesh echo (quick mode) p50 and p95 within ±0.2% of TCP across 4 scenarios; see `artifacts/perf-summary.md` for table and raw medians.
  - PREFER_QUIC wiring landed in `htx::mux`: when `PREFER_QUIC` is truthy and `HTX_SCHEDULER_PROFILE` is unset, defaults to HTTP-friendly window/chunk sizes (unit test added).
  - Headless Linux build: `apps/stealth-browser/build.rs` gates `tauri_build` behind the `with-tauri` feature to keep CI/headless builds green without GUI deps.

## recent updates (2025-09-13)
- M3 catalog pipeline implemented: Rust CLI `catalog-signer` added to workspace; signs YAML templates to JSON + detached Ed25519 signature over DET-CBOR.
  - CLI subcommands: `sign` (YAML → JSON → DET-CBOR → Ed25519 sig), `verify` (check sig with pinned pubkey), `pubkey` (derive pubkey from seed).
  - Smoke test: generated `dist/catalog.json` + `.sig` from `qnet-spec/templates/decoys.yml` and `catalog.meta.yml`; verified with example pubkey (verify ok: schema_version=1, catalog_version=1, entries=2).
  - Templates authored: decoys.yml (2 entries), catalog.meta.yml (metadata + update_urls).
  - Docs updated: catalog-schema.md cross-linked; catalog-signer.md matches CLI; ARCHITECTURE.md added "Catalog-first configuration (M3)" section.
  - Example artifacts: catalog.example.json, .sig, keys/publisher.pub (derived from deterministic seed for tests).
  - Bootstrap policy: Online seeds are DISABLED by default. New env kill switch `STEALTH_DISABLE_BOOTSTRAP` defaults to `1` (on). To explicitly allow seeds for dev/testing, set `STEALTH_DISABLE_BOOTSTRAP=0` and `STEALTH_BOOTSTRAP=1`. The app also gates its connectivity monitor behind this flag; `/status` reports `bootstrap: false` when disabled.

## recent updates (2025-09-14)
- Seedless signed+ship flow clarified for end users: no env catalogs in production. Clients ship with a signed, bundled default catalog, verify it at start, and can fetch a newer signed catalog from mirrors defined in `update_urls`.
- Added a Routine Checkup task in the app backend (headless stub): on first run it (1) downloads+verifies the latest catalog, (2) loads the decoy catalog (preferring signed file), (3) calibrates decoys, and (4) prepares for peer discovery. Status now surfaces `checkup_phase`, `decoy_count`, and `peers_online` (stubbed to 0 until discovery is wired).
- Decoy catalog flow clarified: clients load a signed decoy catalog from disk (or bundled assets). Env-based catalogs are for dev only (when explicitly enabled).
- DecoyDirect demo and references have been removed. Focus is on the signed decoy catalog only.

## repo-local parity evidence (2025-09-12)
- Added a simple RR write scheduler in `htx::mux` (enabled by `HTX_SCHEDULER_RR=1` or when `HTX_SCHEDULER_PROFILE=http` / `PREFER_QUIC=1`).
- Deterministic unit test verifies small stream completes under large-stream contention.
- Micro-benchmark added: `crates/htx/benches/mixed_concurrency.rs` (feature `perf-bench`).
  - Run: `cargo bench -p htx --features perf-bench --bench mixed_concurrency`
  - Notes: sets `HTX_SCHEDULER_RR=1` and `HTX_SCHEDULER_PROFILE=http` during the bench; captures small-stream completion behavior under contention.
  - Use alongside `core-mesh` benches (TCP vs QUIC) to compare p50/p95; see `crates/core-mesh/benches/echo.rs` (enable `--features "with-libp2p quic"`).
 - Decoys (production): Edit or create `qnet-spec/templates/decoy-catalog.json` with your entries, then sign it with `catalog-signer` (or your publisher workflow). The app’s Routine Checkup prefers a signed file on disk (or shipped in assets) over env.

## objective
Build a user-facing stealth browser that:
- Mimics standard HTTPS (TCP-443/QUIC-443) so traffic is indistinguishable in packet captures.
- Auto-connects globally within 30 seconds, preferring a signed, bundled catalog with background updates; seeds remain as a fallback path.
- Routes via configurable decoy IPs/domains to keep ISP logs plausible.
- Lets users browse censored sites with <200ms added latency over baseline.

Success criteria:
- DPI evasion: On Wireshark, traffic looks like normal HTTPS; no QNet signatures.
- Connectivity: First successful connection <30s on commodity networks.
- UX: Can reach a known blocked domain via QNet path; page content loads; no visible warnings.
- Ops: Installers for Windows/macOS/Linux with auto-daemon launch.

---

## deliverables
- apps/stealth-browser/ (Tauri-based desktop app)
  - src-tauri/: Rust backend; integrates QNet client and control plane
  - ui/: Minimal UI (address bar, status, settings)
  - config/: Decoy list, bootstrap seeds, feature flags
- crates/htx + crates/core-framing
  - "stealth-mode" feature flag: TLS-like record sizing, padding, ALPN shaping, JA3-aligned templates
  - Decoy routing: config-driven list of domains/IPs for plausible egress
  - Bootstrap seeds: public nodes list and fallback mechanics
- Installers
  - Windows MSI (WiX or NSIS), macOS DMG, Linux AppImage
- CI
  - Build-and-sign (dev certs) of installers on tagged releases
  - DPI check job with pcap artifact (synthetic capture)
  - Catalog publisher workflow to build/sign catalog and publish to mirrors
- Docs
  - apps/README.md with quick start
  - qnet-spec/specs/001-qnet/T6.7-playbook.md (this file)
  - Acceptance and test scripts (Wireshark/DPI guidance)

---

## architecture
- App shell: Tauri (Rust backend + WebView UI)
- Network path: Browser -> local SOCKS5 inside Tauri -> HTX tunnel -> QNet peers
- Stealth layer (crates/core-framing + crates/htx):
  - Origin-mirrored TLS templates (reusing T2.x capabilities)
  - TLS-like record splitting, padding, timing jitter (bounded)
  - QUIC/TCP toggles; auto-calibration per path
- Config
  - Decoy catalog (signed) bundled with the app and cached on disk with TTL; background updater from mirrors
  - Bootstrap seeds + backoff plan retained as a resilience fallback
  - Feature flags: stealth-mode, prefer-quic, measure-latency

---

## gap analysis — what’s missing to hit T6.7

These items are not yet present in the codebase and must be implemented to satisfy the objectives and success criteria. Each bullet maps to milestones below.

- App shell and local proxy (M1)
  - Tauri app skeleton in `apps/stealth-browser/` with Rust backend
  - Embedded SOCKS5 proxy bound to 127.0.0.1 and exposed in the UI
  - Minimal UI (address bar, status, basic settings) and request path via SOCKS→HTX

- Stealth-mode implementation (M2)
  - TLS-like record splitting/sizing and bounded padding strategies with tests
  - Timing jitter for inter-record gaps with deterministic test mode
  - ALPN shaping and JA3-aligned ClientHello templates with rotation policy
  - QUIC/TCP auto-calibration and HTTP-like stream scheduling defaults

- Decoy routing and plausibility (M2–M3)
  - Decoy catalog schema (JSON/CBOR) with signed presets
  - Resolver mapping real destinations to decoys; rotation policies (time/volume)
  - Log-plausibility alignment: SNI/ALPN/template consistency with chosen decoy

- Catalog-first distribution (M3)
  - Signed, bundled catalog as primary; on-disk cache with TTL
  - Background updater from update_urls (GitHub/CDN); pinned publisher keys
  - Seeds retained as fallback for resilience/emergency updates

- Validation harnesses (M5)
  - DPI parity harness: pcap generation and comparison vs Chrome baseline; CI artifact
  - E2E page-load/TTFB latency measurements with <200ms added median target
  - Censorship-route tests and simulated ISP-log verification (decoys only visible)

- Packaging and CI (M4)
  - Build scripts for Windows MSI, macOS DMG, Linux AppImage
  - CI matrix (linux/windows/macos), dev-signing, artifact publication
  - Auto-daemon launch and firewall prompt guidance for installers

- Security and hardening (M6)
  - Zeroize secrets; buffer limits; WebView sandboxing and CSP
  - Config preset signing and verification; safe local overrides
  - SBOM + dependency audit; threat model doc and checklist

Note: Meeting the <30s global-connect target depends on operating real, reachable bootstrap seed nodes. This external infrastructure must be provisioned alongside code changes.

---

## Milestone plan (phased)

### M1 — Foundation (Week 1–2) [M1: Done]
- [x] Scaffold Tauri app in apps/stealth-browser/
- [x] Embed minimal Rust backend (tokio runtime, config loader)
- [x] Integrate local SOCKS5 proxy bound on 127.0.0.1:PORT
- [x] Wire HTX dial/accept via existing crates; basic echo to validate path
- [x] Logging: structured logs, rotating files, redact secrets
  (UI items moved to M3)

Exit (Done): Can load a simple HTTP(S) site via HTX tunnel using SOCKS proxy (validated via curl over SOCKS).

### M2 — Stealth networking (Week 3–4) [M2: Done]
- [x] Implement feature flag: htx/stealth-mode
  - Crates: `htx`, `core-framing`
  - Cargo features: `stealth-mode` (default: off)
  - Runtime env toggles (dev/test): `STEALTH_SIZING_PROFILE=small|webby|bursty`, `STEALTH_JITTER_PROFILE=small|webby`, `STEALTH_SIZER_SEED`, `STEALTH_JITTER_SEED`
  - Behavior: when on, enable variable record sizing and bounded jitter in HTX mux write path; STREAM padding applied pre-AEAD; ALPN/JA3 shaping via template rotation.
- [x] TLS-like record sizing and padding profiles (small, webby, bursty)
  - [x] Profiles implemented in `core-framing::sizing` with deterministic seeds; bounded ≤64KiB
  - [x] Integrated into HTX mux to shape send chunk size prior to encryption
  - [x] Padding: right-pad applied in HTX STREAM frames (id||len||data||pad) before AEAD; decode remains backward-compatible
  - [x] Zeroize temporary/plaintext buffers after encode when stealth-mode enabled
  - [x] Tests: AEAD round-trip with padding; padded decode (plain/encrypted)
  - [x] Tests: distribution sanity (CDF buckets) for sizing profiles (Webby majority ≤10KiB)
- [x] Timing jitter (bounded) for inter-record gaps
  - [x] Jitter implemented and threaded into HTX mux (sleep before send); deterministic seeds via env
  - [x] Back-pressure aware: skip jitter if we just blocked on credit
  - [x] Tests: determinism with fixed seed
  - [x] Tests: bound checks for Webby profile (2–15ms)
- [x] ALPN shaping and JA3-aligned client hello templates
  - Source: reuse `utls-gen` output and `htx::tls_mirror` calibrations; cache for 24h
  - Rotation: per-conn template rotation via env allow-list (M2 PoC); signed catalog + cadence policy next
  - ALPN order preserved from template; enforce extension order
  - Tests: TemplateID stability and JA3 variance across rotations
  - [x] Tests: JA3 parity vs reference fixtures; rotation cadence tests
- [x] QUIC mode parity: stream scheduling + flow-control defaults for web traffic
  - [x] Add `prefer_quic` config (wired: `PREFER_QUIC` biases scheduler to HTTP-friendly defaults when no explicit profile is set)
  - Align stream concurrency to HTTP/2-like patterns (future when QUIC datapath enabled)
  - [x] Scheduler: weight smaller streams, fair-queue/coalesce small writes; window defaults tuned for TTFB (RR scheduler in `htx::mux`)
  - [x] Tests/benches: deterministic mixed small/large unit test in HTX and a mixed concurrency bench; p50/p95 comparison available via `core-mesh` TCP vs QUIC echo benches
- [x] Configurable decoy routing (domains/IPs) with rotation policies
  - [x] Schema: signed JSON/CBOR { version, updated_at, entries: [ {host_pattern, decoy_host, alpn?, port?, weight?} ], signature_hex }
  - [x] Signature: Ed25519 over deterministic CBOR; env-pinned pubkey via `STEALTH_DECOY_PUBKEY_HEX`
  - [x] Resolver: map real destination → decoy with weighted rotation; optional ALPN override
  - [x] Logs: surface only decoy host/IP when enabled (plausibility)
  - [x] Tests: signature verify; resolver selection and ALPN override
- [x] Bootstrap seed list + fallback + backoff + caching
  - [x] Seeds: signed list schema + verifier (same mechanism as decoys); env loader
  - [x] Backoff: 0.5s → 8s exponential with jitter; cap 30s; 24h cache type
  - [x] Tests: signature verify; backoff under <30s cumulative in failure loop; cache; weighted pick; try_connect_loop succeeds under 29s in unit test
  - [x] Integration hook: env-driven bootstrap gate before dial; health probe (`/health`) with rustls client
  - [x] External seeds + acceptance run: demonstrate <30s first connect using deployed seeds
    - Evidence (2025-09-12): artifacts/bootstrap/run_1.txt, run_2.txt, run_3.txt (all <1.2s); seeds recorded in artifacts/bootstrap/seeds_used.json; method: Cloudflare Quick Tunnel (public HTTPS) on two laptops

Exit (Done): Packet capture is visually indistinguishable from HTTPS for standard browsing flows.
  - Evidence (2025-09-12): artifacts/dpi/qnet-stealth-20250912_142733.pcapng vs artifacts/dpi/chrome-baseline-20250912_142541.pcapng
    - Comparator output: Result: PASS (max Δ=0.028, threshold=0.100); Packets: stealth=16377 baseline=6363
    - Method: Windows Wireshark/tshark capture for 60s each using `qnet-spec/templates/dpi-capture.ps1` (Interface: Wi‑Fi index 3), compared via `qnet-spec/templates/dpi-compare.py`

M2 implementation notes
- Feature flag plumbing
  - Thread the `stealth-mode` feature through `htx` and `core-framing`; expose a runtime config toggle to allow on/off without rebuild (test-only acceptable to require rebuild for M2).
- Record sizing & padding
  - Implemented variable chunk sizing in mux write path under feature flag; respects remote credit (never exceeds WINDOW_UPDATE).
  - Implemented right-padding at STREAM frame level (payload = id||len||data||pad) so record on wire matches target length. Decoder supports legacy frames (id||data) seamlessly.
  - Zeroization of plaintext buffers after encode is enabled under stealth-mode. Add distribution tests next.
- Timing jitter
  - Implemented: apply delay right before send when credit is available; skipped if we blocked on credit wait.
  - Add metrics hooks (disabled by default) to measure added delay distributions.
- ALPN/JA3 shaping
  - Implemented env-driven allow-list rotation and 24h cache; TemplateID computed via deterministic CBOR; JA3 hash varies across templates. Validate with Wireshark JA3 plugin and captured pcaps from Chrome/Firefox baselines.
  - Keep a minimal signed template catalog; prefer dynamic calibration where allowed.
- Decoy routing
  - Implemented `htx::decoy` module with signed catalog loader (DET-CBOR + Ed25519) and resolver with weighted rotation and optional ALPN override. Enabled via env: `STEALTH_DECOY_CATALOG_JSON`, `STEALTH_DECOY_PUBKEY_HEX`, optional `STEALTH_DECOY_ALLOW_UNSIGNED` for dev.
  - `htx::api::dial()` consumes resolver output to route to decoy host/port and pass ALPN override to template selection. Start with DNS-over-OS; future: DoH/DoT if required.
  - Keep resolver optional; when off, behavior defaults to calibration/allow-list paths. Optional redaction via `STEALTH_LOG_DECOY_ONLY=1` hides real destinations in logs.

Env controls (M2)
- STEALTH_SIZING_PROFILE, STEALTH_SIZER_SEED
- STEALTH_JITTER_PROFILE, STEALTH_JITTER_SEED
- STEALTH_TPL_ALLOWLIST (ALPN/JA3 template rotation)
- STEALTH_DECOY_CATALOG_JSON, STEALTH_DECOY_PUBKEY_HEX, STEALTH_DECOY_ALLOW_UNSIGNED
- STEALTH_LOG_DECOY_ONLY (when =1, redact real destination in logs if decoys are used)
- Bootstrap
  - Provide a local fallback (loopback HTX) in dev; real seeds gated by infra availability.
  - `PREFER_QUIC=0|1`: when truthy and `HTX_SCHEDULER_PROFILE` is unset, defaults scheduler to the HTTP profile (initial_window=256KiB, base_chunk=16KiB).
  
HTX scheduler controls (M2)
- HTX_SCHEDULER_PROFILE: "http" enables initial_window=256KiB and base_chunk=16KiB (HTTP-friendly). Default profile uses 64KiB/4KiB.
- HTX_INITIAL_WINDOW: override initial receive window (bytes).
- HTX_CHUNK: override base chunk size (bytes, 512..64KiB).

Config examples (M2)
- Decoys: copy `qnet-spec/templates/decoy-catalog.example.json` and set `STEALTH_DECOY_CATALOG_JSON` to its contents (or path if your launcher reads files). For signed use, also set `STEALTH_DECOY_PUBKEY_HEX` and wrap as `{ "catalog": {…}, "signature_hex": "…" }`.
- Bootstrap: copy `qnet-spec/templates/bootstrap-seeds.example.json` and set `STEALTH_BOOTSTRAP_CATALOG_JSON`; for signed use, also set `STEALTH_BOOTSTRAP_PUBKEY_HEX`.

M2 validation
- Unit tests
  - Sizing distributions and bounds
  - Padding correctness and AEAD integrity
  - Jitter determinism and bounds
  - Template ID/JA3 parity vs fixtures
  - Decoy/seed signature verification
- Integration tests
  - E2E: SOCKS → HTX with `stealth-mode` enabled; confirm payload delivery and bounded added delay
  - DPI: capture 60s browsing of three sites; compare record size CDFs within ±10% to Chrome baseline
  - Connectivity: <30s first connect using a seeded simulation or local proxy of seed endpoints
- CI artifacts
  - Store pcaps and summary in `artifacts/dpi/` with host/date/version metadata
  - Attach distribution plots for record sizes and inter-record gaps
  - Scripts available: `templates/dpi-capture.sh` and `templates/dpi-compare.py`

How to run (local, optional)
- Capture stealth run: enable `stealth-mode`, exercise browsing via the SOCKS proxy, then run: `templates/dpi-capture.sh qnet-stealth`
- Capture baseline (Chrome): browse the same sites, then run: `templates/dpi-capture.sh chrome-baseline`
- Compare: `python3 templates/dpi-compare.py artifacts/dpi/qnet-stealth-*.pcap artifacts/dpi/chrome-baseline-*.pcap`

### M3 — Catalog pipeline (Week 5)
- [x] Catalog signer and templates
  - [x] Create `catalog-signer` (Rust bin): YAML → JSON → DET-CBOR → Ed25519 (detached) signature
    - [x] Docs/spec prepared: see `qnet-spec/docs/catalog-signer.md`
    - [x] Implementation: Rust CLI under `crates/catalog-signer`
  - [x] Author `/templates/decoys.yml` and `/templates/catalog.meta.yml` (schema_version, ttl, publisher_id, update_urls)
  - [x] Emit `catalog.json` and `catalog.json.sig`; verify with pinned pubkey
    - [x] Example artifacts added: `qnet-spec/templates/catalog.example.json`, `.sig`, and `qnet-spec/templates/keys/publisher.pub`
    - [x] Implementation: generate real outputs via signer and verify with pinned key
- [x] Bundle catalog in app
  - [x] Add `assets/catalog-default.json` (+ `.sig` or inline) to `apps/stealth-browser` and embed at build
  - [x] Decide cache path (per-OS app data) and TTL enforcement policy
    - Evidence: uses `directories` crate cache dir; rejects expired catalogs by `expires_at`.
- [x] Loader + verifier + persistence
  - [x] Load cached (verify + fresh) → else bundled (verify); atomic write; keep last-known-good
  - [x] Expose source (bundled/cached/remote), version, expiry via a small status API
    - Evidence: `apps/stealth-browser/src/main.rs` (CatalogState::{init_load,parse_and_verify,persist_atomic}); `/status` JSON includes catalog fields.
- [x] Updater from mirrors
  - [x] Fetch from `update_urls` (GitHub raw/Pages/CDN); verify; compare version/expiry; replace cached atomically
  - [x] Add a "Check for updates" trigger; backoff and error logging
    - Evidence: HTTP endpoint `GET /update` (alias `GET /check-updates`) triggers a one-shot update; `/status` includes `last_update` with `{ updated, from, version, error, checked_ms_ago }`.
- [x] Connected semantics (seedless online)
  - [x] Mark state=connected after the first successful SOCKS CONNECT (no seeds required); surface in `/status` and logs
  - [x] Document semantics in `qnet-spec/docs/apps/stealth-browser.md` and reference from the playbook
  - Evidence: `qnet-spec/docs/apps/stealth-browser.md` — see "Seedless “online” flip (dev convenience)"; `/status` shows `state: connected` after first SOCKS CONNECT.
- [x] Seedless-by-default startup policy
  - [x] Disable bootstrap seeds by default (kill-switch on); status exposes `bootstrap: false`; explicit toggle required for dev/test
  - [x] Catalog-first operation is the primary path; background updater uses `update_urls`
- [x] Routine Checkup (backend) and status fields
  - [x] First-run background task: download+verify latest catalog → load decoy catalog → calibrate → prepare peer discovery
  - [x] Expose `checkup_phase`, `decoy_count`, and `peers_online` (stub until discovery wired) in `/status`
- [x] Decoy catalog acceptance (signed-only)
  - [x] Routine Checkup prefers signed decoy catalog on disk (or shipped in assets) over env
  - [x] Plan: expand decoy catalog for common masking pairs (e.g., google.com → youtube.com) and add CI artifacts alongside the main catalog
    - Evidence: Expanded defaults in `qnet-spec/templates/decoy-catalog.json` (google→youtube, wikipedia→wikimedia, plus a diversified catch‑all pool: cloudflare/microsoft/amazon/apple/netflix/reddit/linkedin/yahoo/github/stackoverflow). Policy and precedence documented in `qnet-spec/docs/apps/stealth-browser.md` under "Masking policy defaults (M3)".
- [x] Publisher repo & CI
  - [x] Create `qnet-catalogs` repo and add build-sign-publish workflow to produce `dist/catalog.json` (+ `.sig`)
  - Evidence: Template workflow ready at `qnet-spec/templates/catalog-publish-workflow.yml`; docs in `qnet-spec/docs/catalog-publisher.md` define repo layout, secrets, verification, and bundling contract. For in-repo setup, copy the template to `.github/workflows/` and add `CATALOG_PRIVKEY` secret to enable automated signing.
  - [x] Document pubkey fingerprints and rotation in README/UI
  - Note: With `CATALOG_PRIVKEY` secret added to GitHub Actions, CI can now automatically sign catalogs on template changes, publishing to raw URLs for browser verification during Routine Checkup.
- [x] Edge gateway service (production masked browsing)
  - [x] Server accept in htx (library): Added `htx::api::accept(bind)` under `rustls-config`. Performs rustls server handshake, derives exporter EKM, binds inner keys (EKM-only), starts inner mux.
  - [x] Edge gateway binary: `apps/edge-gateway` listens on `BIND` (default 0.0.0.0:4443), reads an HTTP CONNECT prelude, replies `200 Connection Established`, and bridges bytes over an inner secure stream.
  - [x] Certificates and catalog: Added `qnet-spec/templates/edge-gateway.example.env` for local self-signed smoke tests; production should use valid certs and extend the signed decoy catalog with edge hostnames.
  - [x] Client handshake polish: Masked mode already bridges over an inner secure stream; CONNECT prelude is honored at the gateway and 200 is returned before tunneling.
  - Evidence (2025-09-14): Local smoke run on Windows — started gateway with self-signed cert; ran stealth-browser with `STEALTH_MODE=masked` and fetched `/status` via SOCKS. CONNECT succeeded and `state: "connected"` observed. Outer TLS negotiated ALPN [h2,http/1.1].

Exit(Done): Catalog-first path working end-to-end (bundled+signed + updater + fallback) and surfaced in a minimal status API; edge gateway enables production masked browsing.

##### How to verify the M3 Exit (Windows, dev)

Follow these quick steps to reproduce the exit criteria on a local machine. This uses the bundled signed catalog by default, the edge gateway on a self‑signed cert, and the app’s minimal status API.

Prereqs
- Built binaries exist at `target/debug/edge-gateway.exe` and `target/debug/stealth-browser.exe`.
- A TLS cert/key for the gateway (self-signed is fine for local). See `../../templates/edge-gateway.example.env` for env names.

1) Start the edge gateway (outer TLS terminator)
- Set env (example values; adjust paths):

```powershell
$env:BIND = "0.0.0.0:4443"          # listen addr:port for outer TLS
$env:HTX_TLS_CERT = "P:\GITHUB\qnet\certs\edge.crt"
$env:HTX_TLS_KEY  = "P:\GITHUB\qnet\certs\edge.key"
P:\GITHUB\qnet\target\debug\edge-gateway.exe
```

2) Start the stealth browser in masked mode with a status port

```powershell
$env:STEALTH_MODE = "masked"
$env:STEALTH_STATUS_PORT = "18080"
P:\GITHUB\qnet\target\debug\stealth-browser.exe
```

3) Drive one request through the local SOCKS proxy to flip state → connected
- Use Windows’ real curl (avoid the PowerShell alias):

```powershell
%SystemRoot%\System32\curl.exe --socks5-hostname 127.0.0.1:1080 http://127.0.0.1:18080/status
```

Expected
- The command above returns JSON with fields like:
  - `state: "connected"` (flips after the first successful SOCKS CONNECT)
  - `catalog.source: "bundled" | "cached" | "remote"`, `catalog.version`, `catalog.expires_at`
  - `bootstrap.mode: "disabled"` (seedless-by-default policy)
  - `checkup_phase`, `decoy_count`, and `peers_online` (stubbed until discovery)

4) Optional: test the updater

```powershell
%SystemRoot%\System32\curl.exe http://127.0.0.1:18080/update
%SystemRoot%\System32\curl.exe --socks5-hostname 127.0.0.1:1080 http://127.0.0.1:18080/status
```

- `/status` now includes `last_update` with `{ updated, from, version, error, checked_ms_ago }`.

Notes
- Cross‑refs: see `../../docs/apps/stealth-browser.md` (edge gateway + status details) and `../../docs/crates/htx.md` (server accept API). Env template: `../../templates/edge-gateway.example.env`.
- Windows: close running binaries before rebuilding to avoid file‑lock errors on `target\debug\*.exe`.

#### Optional next steps (prod UX hardening)
- UI “Check for updates”: add a user-triggered updater action and surface last-update result/timestamp in both the status endpoint and UI.
- Tests: unit tests for TTL rejection and signature verification; integration test that a single SOCKS connection flips state to connected without bootstrap.
- Publisher automation: create `qnet-catalogs` repo with a CI workflow to build/sign/publish `dist/catalog.json` (+ `.sig`); document pubkey fingerprints and rotation policy.
- Troubleshooting docs: add a Windows note about PowerShell aliasing `curl` to `Invoke-WebRequest` and preferring `%SystemRoot%\System32\curl.exe` when testing SOCKS.

### M4 — UX + resilience (Week 6)
- [ ] GUI “Routine Checkup” window (first-run)
  - [ ] Progress UI bound to backend phases: downloading-catalog → loading-decoys → calibrating → peer-discovery → ready
  - [ ] Retry/diagnostics if a phase fails; link to local logs; skip on subsequent runs
  - [ ] Reflect seedless-by-default policy and show when bootstrap is disabled
- [ ] UI: address bar + Go; open via embedded request client through SOCKS
  - [ ] Design and implement address bar UI (HTML/CSS/JS in Tauri frontend)
  - [ ] Wire "Go" button to send URL to Rust backend via Tauri's IPC
  - [ ] Integrate embedded request client to handle navigation through SOCKS proxy
  - [ ] Add basic navigation controls (back/forward, refresh)
- [ ] Basic settings panel (port, bootstrap toggle)
  - [ ] Create settings UI panel (modal or sidebar) with form inputs
  - [ ] Add SOCKS port configuration (default 1080, editable)
  - [ ] Implement bootstrap toggle (enable/disable seed discovery)
  - [ ] Wire settings to persist in local config (e.g., JSON file)
- [ ] Settings for decoy list management (preset + custom)
  - [ ] Display active signed catalog (source: bundled/cached/remote), version, expiry
  - [ ] Import a signed catalog (verify signature) and switch active
  - [ ] Validate decoy entries (e.g., reachable, valid format)
  - [ ] Persist catalog cache (atomic replace) and show last updated/expiry
  - [ ] Full-domain masking presets: expand signed catalog coverage for common sites (e.g., google → youtube) with safe defaults; allow policy selection
- [ ] Connectivity health: spinner, retry UI, error surfaces
  - [ ] Add status indicator (connected/calibrating/offline) with spinner animation
  - [ ] Implement retry button for failed connections
  - [ ] Surface error messages (e.g., "No valid catalog; using bundled", "Update failed; retrying", "Bootstrap fallback engaged")
  - [ ] Poll connectivity status from Rust backend every 5s
- [ ] First-run wizard: consent + quick calibration (origin selection)
  - [ ] Create multi-step wizard UI (consent page, origin selection)
  - [ ] Add privacy consent checkbox and terms link
  - [ ] Implement origin calibration (test connection to selected site)
  - [ ] Skip wizard on subsequent runs (flag in config)
- [ ] Auto-update channel (optional, dev certs) or release notes fetcher
  - [ ] Fetch latest release notes from GitHub API on app start
  - [ ] Display update notifications (optional, non-intrusive)
  - [ ] Implement basic auto-update for dev builds (Tauri supports this)
- [ ] Crash reporting (local-only logs, no telemetry exfiltration)
  - [ ] Capture and log errors to local file (e.g., app_data/logs/)
  - [ ] Add "Export Logs" button in settings for user download
  - [ ] Ensure no data is sent externally (local-only)

Exit: Usable for non-technical users with clear state and recovery.

### M5 — Packaging (Week 7)
- [ ] Windows MSI build (WiX/NSIS) with start menu entry
- [ ] macOS universal build + DMG with app bundle IDs
- [ ] Linux AppImage with desktop file
- [ ] Post-install first-run check and firewall prompts guidance

Exit: Installers build reproducibly on CI and run on clean VMs.

### M6 — DPI & censorship tests (Week 8)
- [ ] Wireshark test playbook with golden pcaps (local lab)
- [ ] ISP-log simulation (squid/sflow) shows decoy sites only
- [ ] Known-blocked domains reachable via QNet
- [ ] Added latency measured (<200ms over direct baseline on clean path)

Exit: Acceptance criteria validated with artifacts.

### M7 — Security & hardening (Week 9)
- [ ] Memory limits for buffers; zeroize secrets
- [ ] Sandboxing constraints for WebView
- [ ] Integrity of config (signed presets) and safe overrides
- [ ] Dependency audit; lockfile maintained
- [ ] Threat model doc + mitigations checklist

Exit: Security review completed, issues triaged or fixed.

---

## detailed checklists

### app scaffolding
- [x] Create apps/stealth-browser via `tauri init`
- [x] Add `qnet` workspace integration (Cargo workspace member)
- [x] Backend: tokio, tracing, serde, config hot-reload
- [ ] SOCKS5 proxy: expose bound address to UI
- [x] Basic request through SOCKS -> HTX (in-proc) -> HTTP 200 echo

### stealth-mode (htx/core-framing)
- [x] Feature flag `stealth-mode` plumbed end-to-end
- [x] Record sizing strategy module + tests (deterministic profiles)
- [x] Padding correctness tests (AEAD round-trip, back-compat decode); [x] bounds/distribution CDF tests
- [x] Timing jitter with deterministic test mode
- [x] ALPN/JA3 selection + env allow-list rotation; [x] parity fixtures + cadence policy
- [x] QUIC stream scheduler tuned for HTTP-like concurrency

### decoy routing & bootstrap
- [x] Decoy catalog schema (JSON/CBOR) + signed preset (Ed25519 over DET-CBOR)
- [x] Resolver that maps destinations to decoys (host-pattern) with ALPN override
- [x] Rotation policy (weighted round-robin; time/volume cadence can extend later)
- [x] Bootstrap seeds list + health checks (`/health`), env loader
- [x] Backoff + cache (0.5s→8s, ±10% jitter); [ ] offline mode messaging (UI)

### UX & controls
- [ ] Address bar + navigation
- [ ] Status indicators: Connected / Calibrating / Offline
- [ ] Settings: decoys, transports (TCP/QUIC/auto), data saver
- [ ] First-run wizard + consent
- [ ] Local-only crash logs export button

### packaging & distribution
- [ ] Windows: code signing (dev), MSI installer
- [ ] macOS: app bundle + DMG, notarization (dev)
- [ ] Linux: AppImage + desktop entry
- [ ] CI: build matrix per OS, artifacts uploaded

### testing & validation
- [ ] Unit tests for padding, record sizing, jitter
- [ ] Integration: SOCKS -> HTX tunnel E2E page load
- [ ] Catalog updater integration: mirrors, tamper rejection, rollback to last-known-good
- [ ] DPI: pcap diff vs. baseline Chrome to ensure parity
- [ ] Latency: added latency <200ms on reference links
- [ ] Censorship: reach blocked domain via QNet

### security
- [ ] Zeroize on key material
- [ ] Minimize capability of WebView; CSP for UI
- [ ] Config signatures verified; local overrides whitelisted
- [ ] Publisher key pinning and rotation process documented (README/UI)
- [ ] SBOM + dependency audit

---

## M3 acceptance checklist
- [x] Catalog signer CLI implemented and tested
  - Evidence (2025-09-13): `catalog-signer sign` generates `dist/catalog.json` + `.sig` from YAML templates; `catalog-signer verify` passes with pinned pubkey (verify ok: schema_version=1, catalog_version=1, entries=2)
- [x] Templates authored and example artifacts present
  - Evidence: `qnet-spec/templates/decoys.yml`, `catalog.meta.yml`, `catalog.example.json`, `.sig`, `keys/publisher.pub`
- [x] Docs updated with catalog-first details
  - Evidence: `docs/catalog-schema.md` cross-linked; `docs/catalog-signer.md` matches CLI; `docs/ARCHITECTURE.md` added M3 section
- [x] Publisher repo & CI workflow documented
  - Evidence: `docs/catalog-publisher.md` with workflow sketch and security notes
- [x] Catalog-first path integrated in app (bundled + updater + status API)
  - Evidence: App builds with embedded catalog; `/status` exposes `catalog_version`, `catalog_expires_at`, `catalog_source`; `/update` triggers a one-shot check and `/status` surfaces `last_update`.

---

## acceptance checklist
- [x] Traffic looks like HTTPS in Wireshark (indistinguishable at record/packet level)
  - Evidence (2025-09-12): PASS (max Δ=0.028) comparing `artifacts/dpi/qnet-stealth-20250912_142733.pcapng` vs `artifacts/dpi/chrome-baseline-20250912_142541.pcapng`
- [x] First connection completes in <30s (catalog-first; seed fallback available)
- [ ] Decoy IPs/domains logged (plausible destinations); real targets masked (via overlay path)
- [ ] Browsing a blocked site works end-to-end
- [ ] Added latency <200ms (median) compared to direct
- [ ] Masked browsing works: SOCKS proxy routes through decoy-shaped outer TLS to cooperating edge gateway, inner stream carries real HTTPS
- [ ] Installers produced for Win/macOS/Linux and run on clean VMs
- [ ] CI green: build, basic E2E test, DPI pcap artifact
- [ ] Security review items addressed or accepted

---

## test playbooks

### wireshark / DPI parity
1) Start the browser with `stealth-mode` enabled.
2) Capture loopback (Linux: `any`) for 60s while loading 3 common sites.
3) Save pcap. Compare against Chrome baseline:
   - TLS record sizes distribution (CDF) within ±10%
   - Inter-record timing jitter bounded and similar
   - ALPN and handshake extensions consistent with template
4) Archive pcap under `artifacts/dpi/` with run metadata (host, date, version).

See `qnet-spec/templates/DPI-README.md` for a full Windows/Linux guide.

Windows quickstart (admin PowerShell)
- Ensure Npcap is running: `Set-Service npcap -StartupType Automatic; Start-Service npcap`
- List interfaces: `tshark -D` (or run by full path)
- Capture baseline: `./qnet-spec/templates/dpi-capture.ps1 -Label chrome-baseline -DurationSeconds 60 -Interface <idx or name>`
- Capture stealth: `./qnet-spec/templates/dpi-capture.ps1 -Label qnet-stealth -DurationSeconds 60 -Interface <same>`
- Compare: `py ./qnet-spec/templates/dpi-compare.py artifacts/dpi/qnet-stealth-*.pcapng artifacts/dpi/chrome-baseline-*.pcapng`

### connectivity / bootstrap
- Cold start on a fresh VM, block direct DNS to target site, allow standard HTTPS.
- Expect connection established <30s; status becomes Connected.

### censorship route
- Configure a known blocked hostname; verify page load via QNet tunnel.
- ISP log simulation (squid/sflow) shows only decoy destinations.

### latency budget
- Measure direct vs. via-QNet TTFB on fixed asset set.
- Added median latency <200ms.

---

## ci considerations
- Matrix builds for linux/windows/macos
- Cache cargo + tauri deps
- Jobs:
  - Build installers (dev-signed), upload artifacts
  - Run headless E2E smoke (load a static page via embedded HTTP server over HTX)
  - Run synthetic DPI test and publish pcap
  - SBOM + audit

---

## catalog publishing automation (qnet-catalogs)

We will publish the signed catalog from a dedicated public repository to decouple signing from the app build and enable safe mirroring.

- Repo: `qnet-catalogs` (public)
- Purpose: Source-of-truth for decoy templates and CI that builds/signs/publishes `catalog.json` (+ detached `.sig`).
- Structure:
  - `/templates/decoys.yml` — human-editable decoys, weights, tags
  - `/templates/catalog.meta.yml` — schema_version, ttl/expiry, publisher_id, update_urls, seed_fallback_urls
  - `/keys/publisher.pub` — Ed25519 public key (committed; fingerprints documented)
  - `/dist/` — CI output: `catalog.json`, `catalog.json.sig`
  - `/.github/workflows/build-sign-publish.yml` — CI pipeline
- Update URLs (used by clients):
  - Raw: `https://raw.githubusercontent.com/<org>/qnet-catalogs/main/dist/catalog.json`
  - Pages mirror: `https://<org>.github.io/qnet-catalogs/catalog.json`
  - Optional CDN mirror: `https://cdn.example.org/qnet/catalog.json`
- Security:
  - Private key stored as GitHub Actions secret in `qnet-catalogs` (e.g., `CATALOG_PRIVKEY`)
  - Branch protection on `main`; lock workflow edits; pin action SHAs; least-privileged tokens
  - Clients verify signatures against pinned pubkeys; mirrors are untrusted transport
- CI workflow (sketch):

```yaml
name: build-sign-publish
on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - 'templates/**'
      - '.github/workflows/build-sign-publish.yml'
jobs:
  build-sign:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
    steps:
      - uses: actions/checkout@<pinned-sha>
      - uses: actions/setup-rust@<pinned-sha>
        with: { rust-version: stable }
      - name: Build signer
        run: cargo install --path crates/catalog-signer
      - name: Generate catalog
        run: |
          mkdir -p dist
          catalog-signer \
            --decoys templates/decoys.yml \
            --meta templates/catalog.meta.yml \
            --out dist/catalog.json \
            --sig dist/catalog.json.sig
        env:
          CATALOG_PRIVKEY: ${{ secrets.CATALOG_PRIVKEY }}
      - name: Verify signature
        run: catalog-signer verify --catalog dist/catalog.json --sig dist/catalog.json.sig --pubkey-file keys/publisher.pub
      - name: Commit dist
        run: |
          git config user.name "qnet-bot"
          git config user.email "bot@users.noreply.github.com"
          git add dist/
          git commit -m "Update catalog dist" || echo "No changes"
          git push
      - name: Release (optional)
        uses: softprops/action-gh-release@<pinned-sha>
        with:
          tag_name: catalog-v${{ github.run_number }}
          files: |
            dist/catalog.json
            dist/catalog.json.sig
      - name: Publish to GitHub Pages (optional)
        uses: peaceiris/actions-gh-pages@<pinned-sha>
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist
          destination_dir: .
          force_orphan: true
```

See `qnet-spec/docs/catalog-schema.md` for the catalog format, signing, TTL, and verification details.

---

## risks & mitigations
- Advanced DPI evolves fast → Maintain multiple templates; quick-update channel
- Decoy catalog abuse → Signed presets; community-reviewed lists
- Legal exposure in restrictive regimes → Prominent disclaimers; jurisdiction-aware defaults
- Performance regressions → Perf guardrails; opt-out of heavy jitter on slow links

---

## artifacts to produce
- apps/stealth-browser installers (MSI, DMG, AppImage)
- pcap comparisons in artifacts/dpi/
- Latency report and acceptance notes in artifacts/browser/
- Decoy catalog snapshot with signature

---

## references
- Spec tasks: qnet-spec/specs/001-qnet/tasks.md (T6.7)
- Prior work: T2.x TLS mirroring, T6.6 perf infra
- Tech choices: Tauri, tokio, quinn/rustls, serde
