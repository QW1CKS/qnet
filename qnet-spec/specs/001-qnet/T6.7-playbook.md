# T6.7 — Stealth Browser Application: Playbook & Acceptance

Status: In progress (M1: backend+logging+SOCKS done; HTX wiring next)
Owner: TBD • Reviewers: Core, Security, Perf
Timebox: ~8 weeks (see milestones)
Dependencies: T6.1–T6.6 complete (toolkit, HTX, perf, compliance)

---

## objective
Build a user-facing stealth browser that:
- Mimics standard HTTPS (TCP-443/QUIC-443) so traffic is indistinguishable in packet captures.
- Auto-connects globally within 30 seconds using public bootstrap seeds.
- Routes via configurable decoy IPs/domains to keep ISP logs plausible.
- Lets users browse censored sites with <200ms added latency over baseline.

Success criteria:
- DPI evasion: On Wireshark, traffic looks like normal HTTPS; no QNet signatures.
- Connectivity: First successful connection <30s on commodity networks.
- UX: Can reach a known blocked domain via QNet path; page content loads; no visible warnings.
- Ops: Installers for Windows/macOS/Linux with auto-daemon launch.

---

## deliverables
- apps/stealth-browser/ (Tauri-based desktop app)
  - src-tauri/: Rust backend; integrates QNet client and control plane
  - ui/: Minimal UI (address bar, status, settings)
  - config/: Decoy list, bootstrap seeds, feature flags
- crates/htx + crates/core-framing
  - "stealth-mode" feature flag: TLS-like record sizing, padding, ALPN shaping, JA3-aligned templates
  - Decoy routing: config-driven list of domains/IPs for plausible egress
  - Bootstrap seeds: public nodes list and fallback mechanics
- Installers
  - Windows MSI (WiX or NSIS), macOS DMG, Linux AppImage
- CI
  - Build-and-sign (dev certs) of installers on tagged releases
  - DPI check job with pcap artifact (synthetic capture)
- Docs
  - apps/README.md with quick start
  - qnet-spec/specs/001-qnet/T6.7-playbook.md (this file)
  - Acceptance and test scripts (Wireshark/DPI guidance)

---

## architecture
- App shell: Tauri (Rust backend + WebView UI)
- Network path: Browser -> local SOCKS5 inside Tauri -> HTX tunnel -> QNet peers
- Stealth layer (crates/core-framing + crates/htx):
  - Origin-mirrored TLS templates (reusing T2.x capabilities)
  - TLS-like record splitting, padding, timing jitter (bounded)
  - QUIC/TCP toggles; auto-calibration per path
- Config
  - Decoy catalog (well-known domains, rotating)
  - Bootstrap seeds + backoff plan
  - Feature flags: stealth-mode, prefer-quic, measure-latency

---

## gap analysis — what’s missing to hit T6.7

These items are not yet present in the codebase and must be implemented to satisfy the objectives and success criteria. Each bullet maps to milestones below.

- App shell and local proxy (M1)
  - Tauri app skeleton in `apps/stealth-browser/` with Rust backend
  - Embedded SOCKS5 proxy bound to 127.0.0.1 and exposed in the UI
  - Minimal UI (address bar, status, basic settings) and request path via SOCKS→HTX

- Stealth-mode implementation (M2)
  - TLS-like record splitting/sizing and bounded padding strategies with tests
  - Timing jitter for inter-record gaps with deterministic test mode
  - ALPN shaping and JA3-aligned ClientHello templates with rotation policy
  - QUIC/TCP auto-calibration and HTTP-like stream scheduling defaults

- Decoy routing and plausibility (M2–M3)
  - Decoy catalog schema (JSON/CBOR) with signed presets
  - Resolver mapping real destinations to decoys; rotation policies (time/volume)
  - Log-plausibility alignment: SNI/ALPN/template consistency with chosen decoy

- Global bootstrap and resilience (M2)
  - Public bootstrap seed list (deployed infra), health checks
  - Fallback/backoff/caching to achieve <30s first connection on commodity networks

- Validation harnesses (M5)
  - DPI parity harness: pcap generation and comparison vs Chrome baseline; CI artifact
  - E2E page-load/TTFB latency measurements with <200ms added median target
  - Censorship-route tests and simulated ISP-log verification (decoys only visible)

- Packaging and CI (M4)
  - Build scripts for Windows MSI, macOS DMG, Linux AppImage
  - CI matrix (linux/windows/macos), dev-signing, artifact publication
  - Auto-daemon launch and firewall prompt guidance for installers

- Security and hardening (M6)
  - Zeroize secrets; buffer limits; WebView sandboxing and CSP
  - Config preset signing and verification; safe local overrides
  - SBOM + dependency audit; threat model doc and checklist

Note: Meeting the <30s global-connect target depends on operating real, reachable bootstrap seed nodes. This external infrastructure must be provisioned alongside code changes.

---

## milestone plan (phased)

### M1 — Foundation (Week 1–2)
- [x] Scaffold Tauri app in apps/stealth-browser/
- [x] Embed minimal Rust backend (tokio runtime, config loader)
- [x] Integrate local SOCKS5 proxy bound on 127.0.0.1:PORT
- [ ] Wire HTX dial/accept via existing crates; basic echo to validate path
- [ ] UI: address bar + Go; open via embedded request client through SOCKS
- [x] Logging: structured logs, rotating files, redact secrets
- [ ] Basic settings panel (port, bootstrap toggle)

Exit: Can load a simple HTTP(S) site via HTX tunnel using SOCKS proxy.

### M2 — Stealth networking (Week 3–4)
- [ ] Implement feature flag: htx/stealth-mode
- [ ] TLS-like record sizing and padding profiles (small, webby, bursty)
- [ ] Timing jitter (bounded) for inter-record gaps
- [ ] ALPN shaping and JA3-aligned client hello templates
- [ ] QUIC mode parity: stream scheduling + flow-control defaults for web traffic
- [ ] Configurable decoy routing (domains/IPs) with rotation policies
- [ ] Bootstrap seed list + fallback + backoff + caching

Exit: Packet capture is visually indistinguishable from HTTPS for standard browsing flows.

### M3 — UX + resilience (Week 5)
- [ ] Settings for decoy list management (preset + custom)
- [ ] Connectivity health: spinner, retry UI, error surfaces
- [ ] First-run wizard: consent + quick calibration (origin selection)
- [ ] Auto-update channel (optional, dev certs) or release notes fetcher
- [ ] Crash reporting (local-only logs, no telemetry exfiltration)

Exit: Usable for non-technical users with clear state and recovery.

### M4 — Packaging (Week 6)
- [ ] Windows MSI build (WiX/NSIS) with start menu entry
- [ ] macOS universal build + DMG with app bundle IDs
- [ ] Linux AppImage with desktop file
- [ ] Post-install first-run check and firewall prompts guidance

Exit: Installers build reproducibly on CI and run on clean VMs.

### M5 — DPI & censorship tests (Week 7)
- [ ] Wireshark test playbook with golden pcaps (local lab)
- [ ] ISP-log simulation (squid/sflow) shows decoy sites only
- [ ] Known-blocked domains reachable via QNet
- [ ] Added latency measured (<200ms over direct baseline on clean path)

Exit: Acceptance criteria validated with artifacts.

### M6 — Security & hardening (Week 8)
- [ ] Memory limits for buffers; zeroize secrets
- [ ] Sandboxing constraints for WebView
- [ ] Integrity of config (signed presets) and safe overrides
- [ ] Dependency audit; lockfile maintained
- [ ] Threat model doc + mitigations checklist

Exit: Security review completed, issues triaged or fixed.

---

## detailed checklists

### app scaffolding
- [x] Create apps/stealth-browser via `tauri init`
- [x] Add `qnet` workspace integration (Cargo workspace member)
- [x] Backend: tokio, tracing, serde, config hot-reload
- [ ] SOCKS5 proxy: expose bound address to UI
- [ ] Basic request through SOCKS -> HTX -> remote echo

### stealth-mode (htx/core-framing)
- [ ] Feature flag `stealth-mode` plumbed end-to-end
- [ ] Record sizing strategy module + tests
- [ ] Padding correctness + bounds tests
- [ ] Timing jitter with deterministic test mode
- [ ] ALPN/JA3 template selection and rotation policy
- [ ] QUIC stream scheduler tuned for HTTP-like concurrency

### decoy routing & bootstrap
- [ ] Decoy catalog schema (JSON/CBOR) + signed preset
- [ ] Resolver that maps destinations to decoys
- [ ] Rotation policy (time-based, volume-based)
- [ ] Bootstrap seeds list + health checks
- [ ] Backoff + cache; offline mode messaging

### UX & controls
- [ ] Address bar + navigation
- [ ] Status indicators: Connected / Calibrating / Offline
- [ ] Settings: decoys, transports (TCP/QUIC/auto), data saver
- [ ] First-run wizard + consent
- [ ] Local-only crash logs export button

### packaging & distribution
- [ ] Windows: code signing (dev), MSI installer
- [ ] macOS: app bundle + DMG, notarization (dev)
- [ ] Linux: AppImage + desktop entry
- [ ] CI: build matrix per OS, artifacts uploaded

### testing & validation
- [ ] Unit tests for padding, record sizing, jitter
- [ ] Integration: SOCKS -> HTX tunnel E2E page load
- [ ] DPI: pcap diff vs. baseline Chrome to ensure parity
- [ ] Latency: added latency <200ms on reference links
- [ ] Censorship: reach blocked domain via QNet

### security
- [ ] Zeroize on key material
- [ ] Minimize capability of WebView; CSP for UI
- [ ] Config signatures verified; local overrides whitelisted
- [ ] SBOM + dependency audit

---

## acceptance checklist
- [ ] Traffic looks like HTTPS in Wireshark (indistinguishable at record/packet level)
- [ ] First connection completes in <30s using public bootstrap
- [ ] Decoy IPs/domains logged (plausible destinations); real targets masked
- [ ] Browsing a blocked site works end-to-end
- [ ] Added latency <200ms (median) compared to direct
- [ ] Installers produced for Win/macOS/Linux and run on clean VMs
- [ ] CI green: build, basic E2E test, DPI pcap artifact
- [ ] Security review items addressed or accepted

---

## test playbooks

### wireshark / DPI parity
1) Start the browser with `stealth-mode` enabled.
2) Capture loopback (Linux: `any`) for 60s while loading 3 common sites.
3) Save pcap. Compare against Chrome baseline:
   - TLS record sizes distribution (CDF) within ±10%
   - Inter-record timing jitter bounded and similar
   - ALPN and handshake extensions consistent with template
4) Archive pcap under `artifacts/dpi/` with run metadata (host, date, version).

### connectivity / bootstrap
- Cold start on a fresh VM, block direct DNS to target site, allow standard HTTPS.
- Expect connection established <30s; status becomes Connected.

### censorship route
- Configure a known blocked hostname; verify page load via QNet tunnel.
- ISP log simulation (squid/sflow) shows only decoy destinations.

### latency budget
- Measure direct vs. via-QNet TTFB on fixed asset set.
- Added median latency <200ms.

---

## ci considerations
- Matrix builds for linux/windows/macos
- Cache cargo + tauri deps
- Jobs:
  - Build installers (dev-signed), upload artifacts
  - Run headless E2E smoke (load a static page via embedded HTTP server over HTX)
  - Run synthetic DPI test and publish pcap
  - SBOM + audit

---

## risks & mitigations
- Advanced DPI evolves fast → Maintain multiple templates; quick-update channel
- Decoy catalog abuse → Signed presets; community-reviewed lists
- Legal exposure in restrictive regimes → Prominent disclaimers; jurisdiction-aware defaults
- Performance regressions → Perf guardrails; opt-out of heavy jitter on slow links

---

## artifacts to produce
- apps/stealth-browser installers (MSI, DMG, AppImage)
- pcap comparisons in artifacts/dpi/
- Latency report and acceptance notes in artifacts/browser/
- Decoy catalog snapshot with signature

---

## references
- Spec tasks: qnet-spec/specs/001-qnet/tasks.md (T6.7)
- Prior work: T2.x TLS mirroring, T6.6 perf infra
- Tech choices: Tauri, tokio, quinn/rustls, serde
